<!DOCTYPE html>
<html>
  <head>
    <title>Applied Machine Learning - Basic Principals</title>
    <meta charset="utf-8">
    <meta name="author" content="Max Kuhn (RStudio)" />
    <link href="libs/remark-css-0.0.1/example.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Applied Machine Learning - Basic Principals
### Max Kuhn (RStudio)

---


# Introduction

In this section, we will introduce concepts that are useful for any type of machine learning model. 

Many of these topics will be put into action in later sections. 


---

# The Modeling _Process_

Common steps during model building are:

* estimating model parameters (i.e. training models)

* determining the values of _tuning parameters_ that cannot be directly calculated from the data

* model selection (within a model type) and model comparison (between types)

* calculating the performance of the final model that will generalize to new data

Many books and courses portray predictive modeling as a short sprint. A better analogy would be a marathon or campaign (depending on how hard the problem is). 


---

# What the Modeling Process Usually Looks Like

&lt;img src="intro-process-1.svg"&gt;


---

# Data Splitting and Spending

How do we "spend" the data to find an optimal model? 

We _typically_ split data into training and test data sets:

*  ***Training Set***: these data are used to estimate model parameters and to pick the values of the complexity parameter(s) for the model.

*  ***Test Set***: these data can be used to get an independent assessment of model efficacy. They should not be used during model training. 


---

# Data Splitting and Spending

The more data we spend, the better estimates we'll get (provided the data is accurate).  

Given a fixed amount of data:

* too much spent in training won't allow us to get a good assessment of predictive performance.  We may find a model that fits the training data very well, but is not generalizable (overfitting)

* too much spent in testing won't allow us to get a good assessment of model parameters

Statistically, the best course of action would be to use all the data for model building and use statistical methods to get good estimates of error.

From a non-statistical perspective, many consumers of complex models emphasize the need for an untouched set of samples to evaluate performance.


---

# Large Data Sets

When a large amount of data are available, it might seem like a good idea to put a large amount into the training set. _Personally_, I think that this causes more trouble than it is worth due to diminishing returns on performance and the added cost and complexity of the required infrastructure. 

Alternatively, it is probably a better idea to reserve good percentages of the data for specific parts of the modeling process. For example: 

* Save a large chunk of data to perform feature selection prior to model building
* Retain data to calibrate class probabilities or determine a cutoff via an ROC curve. 

Also, there may be little need for iterative resampling of the data. A single holdout (aka validation set) may be sufficient in some cases if the data are large enough and the data sampling mechanism is solid.  


---

# Mechanics of Data Splitting

There are a few different ways to do the split: simple random sampling, _stratified sampling based on the outcome_, by date, or methods that focus on the distribution of the predictors.

For stratification:

* **classification**: this would mean sampling within the classes as to preserve the distribution of the outcome in the training and test sets

* **regression**: determine the quartiles of the data set and samples within those artificial groups


---

# Ames Housing Data

Let's load the example data set and split it. We'll put 75% into training and 25% into testing. 


```r
library(AmesHousing)
ames &lt;- make_ames()
nrow(ames)
```

```
## [1] 745
```

```r
library(rsample)

# Make sure that you get the same random numbers
set.seed(4595)
data_split &lt;- initial_split(ames, strata = "Sale_Price")

ames_train &lt;- training(data_split)
ames_test  &lt;- testing(data_split)

nrow(ames_train)/nrow(ames)
```

```
## [1] 0.7530201
```


---

# Outcome Distributions

.pull-left[

```r
library(ggplot2)
## Do the distributions line up? 
ggplot(ames_train, aes(x = Sale_Price)) + 
  geom_line(stat = "density", 
            trim = TRUE) + 
  geom_line(data = ames_test, 
            stat = "density", 
            trim = TRUE, col = "red")
```
]
.pull-right[
&lt;img src="Part_2_Basic_Principals_files/figure-html/ames-split-dists-dist-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---

# Specifying Models in R Using Formulas

To fit a model to the housing data, the model terms must be specified. Historically, there are two main interfaces for doing this. 

The **formula** interface using R [formula rules](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Formulae-for-statistical-models) to specify a _symbolic_ representation of the terms and variables. For example:


```r
foo(Sale_Price ~ Neighborhood + Yr_Sold + Neighborhood:Yr_Sold, data = ames_train)
```
or

```r
foo(log10(Sale_Price) ~ ., data = ames_train)
```
or

```r
foo(log10(Sale_Price) ~ ns(Longitude, df = 3) + ns(Latitude, df = 3), data = ames_train)
```

This is very convenient but it has some disadvantages.  


---

# Downsides to Formulas

* You can't nest in-line functions such as `foo(y ~ pca(scale(x1), scale(x2), scale(x3)), data = dat)`.

* All the model matrix calculations happen at once and can't be recycled when uses in a model function. 

* For very _wide_data sets, the formula method can be [extremely inefficient](https://rviews.rstudio.com/2017/03/01/the-r-formula-method-the-bad-parts/). 

* There are limited _roles_ that variables can take which has led to several re-implementations of formulas. 

* Specifying multivariate outcomes 

* Not all model functions have a formula method. 


---

# Specifying Models Without Formulas

Some modeling function have the non-formula interface. This usually has arguments for the predictors and the outcome(s):


```r
# Ususally, the variables must all be numeric
pre_vars &lt;- c("Yr_Sold", "Longitude", "Latitude")
foo(x = ames_train[, pre_vars],
    y = ames_train$Sale_Price)
```

This is inconvenient if you have transformations, factor variables, interactions, or any other operations to apply to the data prior to modeling. 

Overall, it is difficult to predict if a package has one or both of these interfaces. For example, `lm` only has formulas. 

There is a **third interface**, using _recipes_ that will be discussed later that solves some of these issues. 


---

# A Linear Regression Model 

Let's start by fitting an ordinary linear regression model to the training set. You cna choose the model terms for your model but I will use:


```r
simple_lm &lt;- lm(log10(Sale_Price) ~ Neighborhood + Yr_Sold + Year_Built + House_Style,
                data = ames_train)
```

Before looking at coefficients, we should do some model checking to see if there is anything obviously wrong with the model. 

To get the statistics on the individual data points, we will use the awesome `broom` package:


```r
library(broom)
simple_lm_values &lt;- augment(simple_lm)
```


---

# Some Basic Diagnostics 

From these results, let's take 10 minutes and do some visualizations: 

* Plot the observed versus fitted values

* Plot the residuals

* Plot the predicted versus residuals

Are there any _downsides_ to this approach? 


---

# Overall Model Statistics 

If you use the `summary` method on the `lm` object, the bottom shows some statistics: 


```r
summary(simple_lm)
```

```
## &lt;snip&gt;
## Residual standard error: 0.1088 on 527 degrees of freedom
## Multiple R-squared:  0.6311,	Adjusted R-squared:  0.608 
## F-statistic: 27.33 on 33 and 527 DF,  p-value: &lt; 2.2e-16
```

These statistics are the result of predicting the same data that was used to derive the coefficients. This is problematic because it can lead to (wildly) optimistic results, especially for models that are extremely flexible. 

The tests set is used for assessing performance. **Should we predict the test set** and use those results to estimate these statistics? 


---

&lt;img src="nope.png" height="542" width="400"&gt;

(Matthew Inman/Exploding Kittens)


---

# Assessing Models

Save the test set until the very end when you have one or two models that are your favorite. 

We'll need to use the training set but....

For some models, it is possible to get very small residuals by predicting the training set. 

That's an issue since we will need to make comparisons between models, create diagnostic plots, etc. 

If only we had a method for getting honest performance estimates from the _training set_... ðŸ¤”


---

# Resampling


---

# Model Tuning and Overfitting


---

# Preprocessing and Feature Engineering
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLanguage": "R",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {window.dispatchEvent(new Event('resize'));});
(function() {var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler"); if (!r) return; s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }"; d.head.appendChild(s);})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
